import { Category } from '../types';

export const decorators: Category = {
    id: 'decorators',
    name: 'Decorators',
    description: 'Function and class decorators — wrapping, stacking, parameterized decorators, and built-in decorators',
    icon: 'Layers',
    entries: [
        { id: 'dec-basic', name: '@decorator (Basic)', signature: '@decorator def func(): ...', description: 'A decorator wraps a function with additional behavior. Syntactic sugar for func = decorator(func).', example: 'def log_calls(func):\n    def wrapper(*args, **kwargs):\n        print(f"Calling {func.__name__}")\n        result = func(*args, **kwargs)\n        print(f"Done: {result}")\n        return result\n    return wrapper\n\n@log_calls\ndef add(a, b):\n    return a + b\n\nadd(3, 4)\n# Calling add\n# Done: 7', tags: ['decorator', 'wrap', 'basic'] },
        { id: 'dec-wraps', name: '@functools.wraps', signature: '@functools.wraps(wrapped)', description: 'Preserves the original function\'s metadata (__name__, __doc__) when wrapping.', example: 'from functools import wraps\n\ndef timer(func):\n    @wraps(func)  # Preserves func metadata\n    def wrapper(*args, **kwargs):\n        import time\n        start = time.time()\n        result = func(*args, **kwargs)\n        print(f"{func.__name__}: {time.time()-start:.4f}s")\n        return result\n    return wrapper\n\n@timer\ndef slow():\n    """A slow function."""\n    import time\n    time.sleep(0.1)\n\nslow()\nprint(slow.__name__)  # slow (not "wrapper")\nprint(slow.__doc__)   # A slow function.', edgeCases: ['Without @wraps, the decorated function loses its name and docstring.'], tags: ['wraps', 'metadata', 'preserve'] },

        { id: 'dec-stacking', name: 'Stacking Decorators', signature: '@dec1\\n@dec2\\ndef func(): ...', description: 'Multiple decorators are applied bottom-up. @dec1 @dec2 def f means dec1(dec2(f)).', example: 'def bold(func):\n    def wrapper():\n        return f"<b>{func()}</b>"\n    return wrapper\n\ndef italic(func):\n    def wrapper():\n        return f"<i>{func()}</i>"\n    return wrapper\n\n@bold\n@italic\ndef greet():\n    return "Hello"\n\nprint(greet())  # <b><i>Hello</i></b>', tags: ['stacking', 'compose', 'chain'] },
        { id: 'dec-with-args', name: 'Decorator with Arguments', signature: '@decorator(args) def func(): ...', description: 'Decorators that accept parameters need an extra level of nesting (decorator factory).', example: 'from functools import wraps\n\ndef repeat(times):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\n@repeat(times=3)\ndef greet(name):\n    print(f"Hello, {name}!")\n\ngreet("Alice")\n# Hello, Alice!\n# Hello, Alice!\n# Hello, Alice!', tags: ['parameterized', 'factory', 'configurable'] },
        { id: 'dec-class', name: 'Class Decorators', signature: '@decorator class MyClass: ...', description: 'Decorators can also wrap classes, adding or modifying class behavior.', example: 'def add_repr(cls):\n    def __repr__(self):\n        attrs = ", ".join(f"{k}={v!r}" for k, v in vars(self).items())\n        return f"{cls.__name__}({attrs})"\n    cls.__repr__ = __repr__\n    return cls\n\n@add_repr\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\np = Person("Alice", 30)\nprint(p)  # Person(name=\'Alice\', age=30)', tags: ['class', 'modify', 'enhance'] },
        { id: 'dec-builtin', name: 'Built-in Decorators', signature: '@property, @classmethod, @staticmethod, @dataclass, @abstractmethod, @lru_cache', description: 'Python\'s most important built-in and standard library decorators.', example: 'from functools import lru_cache\n\n# @lru_cache — memoize expensive computations\n@lru_cache(maxsize=128)\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\nprint(fibonacci(100))  # 354224848179261915075 (instant!)\n\n# Other built-in decorators:\n# @property      — getter/setter\n# @classmethod   — cls instead of self\n# @staticmethod  — no self or cls\n# @dataclass     — auto-generate __init__, __repr__, __eq__\n# @abstractmethod — force subclass implementation\n# @wraps         — preserve function metadata', tags: ['builtin', 'lru-cache', 'reference'] },
    ]
};
