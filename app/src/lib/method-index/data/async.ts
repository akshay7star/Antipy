import { Category } from '../types';

export const asyncConcurrency: Category = {
    id: 'async-concurrency',
    name: 'Async & Concurrency',
    description: 'async/await, asyncio, threading, multiprocessing, and the GIL — understanding Python concurrency',
    icon: 'Zap',
    entries: [
        { id: 'async-await', name: 'async / await', signature: 'async def func(): result = await coroutine', description: 'Define and call asynchronous functions. async def creates a coroutine, await pauses until result.', example: 'import asyncio\n\nasync def fetch_data(url):\n    print(f"Fetching {url}...")\n    await asyncio.sleep(1)  # Simulate network delay\n    return f"Data from {url}"\n\nasync def main():\n    result = await fetch_data("https://api.example.com")\n    print(result)\n\nasyncio.run(main())', tags: ['async', 'await', 'coroutine'] },
        { id: 'async-run', name: 'asyncio.run()', signature: 'asyncio.run(coroutine)', description: 'The main entry point for running async code. Creates event loop, runs coroutine, and cleans up.', example: 'import asyncio\n\nasync def main():\n    print("Hello")\n    await asyncio.sleep(1)\n    print("World")\n\nasyncio.run(main())  # Hello (1s pause) World', edgeCases: ['Cannot call asyncio.run() from within an already-running event loop (e.g. Jupyter).'], tags: ['asyncio', 'run', 'entry-point'] },
        { id: 'async-gather', name: 'asyncio.gather()', signature: 'asyncio.gather(*coroutines) -> list', description: 'Run multiple coroutines concurrently and wait for all to complete.', example: 'import asyncio\n\nasync def task(name, delay):\n    await asyncio.sleep(delay)\n    return f"{name} done"\n\nasync def main():\n    results = await asyncio.gather(\n        task("A", 2),\n        task("B", 1),\n        task("C", 3)\n    )\n    print(results)  # [\'A done\', \'B done\', \'C done\']\n    # Total time: ~3s (concurrent, not 6s sequential)\n\nasyncio.run(main())', tags: ['concurrent', 'parallel', 'gather'] },
        { id: 'async-create-task', name: 'asyncio.create_task()', signature: 'asyncio.create_task(coroutine) -> Task', description: 'Schedules a coroutine to run concurrently as a Task. Starts immediately, doesn\'t wait.', example: 'import asyncio\n\nasync def background_job():\n    while True:\n        print("Working...")\n        await asyncio.sleep(2)\n\nasync def main():\n    task = asyncio.create_task(background_job())\n    await asyncio.sleep(5)  # Do other work\n    task.cancel()  # Stop background job\n\nasyncio.run(main())', tags: ['task', 'background', 'schedule'] },
        { id: 'async-threading', name: 'threading Module', signature: 'import threading', description: 'Run functions in parallel threads. Good for I/O-bound tasks. Limited by GIL for CPU tasks.', example: 'import threading\nimport time\n\ndef download(url):\n    print(f"Downloading {url}...")\n    time.sleep(2)  # Simulate I/O\n    print(f"Done: {url}")\n\n# Create threads\nurls = ["url1", "url2", "url3"]\nthreads = [threading.Thread(target=download, args=(url,)) for url in urls]\n\n# Start all\nfor t in threads:\n    t.start()\n\n# Wait for all\nfor t in threads:\n    t.join()\n\nprint("All downloads complete!")  # ~2s total, not 6s', tags: ['threading', 'parallel', 'io-bound'] },
        { id: 'async-multiprocessing', name: 'multiprocessing Module', signature: 'import multiprocessing', description: 'Run functions in separate processes. Bypasses GIL, ideal for CPU-bound tasks.', example: 'from multiprocessing import Pool\nimport math\n\ndef compute_heavy(n):\n    return sum(math.factorial(i) for i in range(n))\n\nif __name__ == "__main__":\n    with Pool(4) as pool:  # 4 worker processes\n        results = pool.map(compute_heavy, [100, 200, 300, 400])\n    print(results)', edgeCases: ['Must use if __name__ == "__main__" guard on Windows.', 'Arguments must be picklable.'], tags: ['multiprocessing', 'cpu-bound', 'parallel'] },
        { id: 'async-gil', name: 'GIL (Global Interpreter Lock)', signature: 'N/A', description: 'CPython\'s GIL allows only one thread to execute Python bytecode at a time. This limits true parallelism for CPU tasks.', example: '# GIL Impact:\n# - Threads CAN run I/O operations in parallel\n# - Threads CANNOT run CPU operations in parallel\n# - Use multiprocessing for CPU-bound parallelism\n\n# I/O-bound: threading is fine\nimport threading\n# File reads, HTTP requests, database queries\n# → Multiple threads run in parallel during I/O waits\n\n# CPU-bound: use multiprocessing\nfrom multiprocessing import Pool\n# Math computations, data processing\n# → Each process has its own GIL', edgeCases: ['Python 3.13+ introduces a free-threaded mode (no GIL) with the --disable-gil flag.'], tags: ['gil', 'concurrency', 'limitation'] },
        { id: 'async-context', name: 'When to Use What', signature: 'N/A', description: 'Choosing between asyncio, threading, and multiprocessing based on your use case.', example: '# Decision flow:\n#\n# Is it I/O-bound (network, files, databases)?\n#   → Many concurrent connections: asyncio\n#   → Few connections, simple code: threading\n#\n# Is it CPU-bound (math, processing)?\n#   → multiprocessing\n#\n# Simple, sequential code?\n#   → Just use normal synchronous code!\n\n# COMPARISON:\n# asyncio:         Single thread, cooperative multitasking\n# threading:       Multiple threads, preemptive, GIL-limited\n# multiprocessing: Multiple processes, true parallelism, heavy', tags: ['comparison', 'decision', 'guide'] },
    ]
};
