import { Category } from '../types';

export const functionsScope: Category = {
    id: 'functions-scope',
    name: 'Functions & Scope',
    description: 'Defining functions, lambda expressions, closures, scope rules, args/kwargs, type hints, recursion',
    icon: 'FunctionSquare',
    entries: [
        { id: 'fn-def', name: 'def (Function Definition)', signature: 'def function_name(params): ...', description: 'Defines a reusable named function. Functions are first-class objects in Python.', example: 'def greet(name):\n    """Greet a person."""\n    return f"Hello, {name}!"\n\nprint(greet("Alice"))  # Hello, Alice!\nprint(greet.__doc__)   # Greet a person.', tags: ['define', 'function', 'basic'] },
        { id: 'fn-return', name: 'return', signature: 'return [expression]', description: 'Exits a function and optionally returns a value. Functions without return return None.', example: 'def add(a, b):\n    return a + b\n\ndef divide(a, b):\n    if b == 0:\n        return None  # Early return\n    return a / b\n\n# Multiple return values (actually a tuple)\ndef min_max(nums):\n    return min(nums), max(nums)\n\nlo, hi = min_max([3, 1, 4, 1, 5])\nprint(lo, hi)  # 1 5', tags: ['return', 'output', 'value'] },
        { id: 'fn-default-args', name: 'Default Arguments', signature: 'def func(param=default_value)', description: 'Parameters with default values. Called without that argument, the default is used.', example: 'def greet(name, greeting="Hello"):\n    return f"{greeting}, {name}!"\n\nprint(greet("Alice"))            # Hello, Alice!\nprint(greet("Bob", "Hi"))        # Hi, Bob!', edgeCases: ['⚠️ NEVER use mutable defaults (list, dict).', 'Use None instead:\ndef bad(items=[])  ← Bug!\ndef good(items=None): items = items or []'], tags: ['default', 'optional', 'parameter'] },
        { id: 'fn-lambda', name: 'lambda (Anonymous Functions)', signature: 'lambda params: expression', description: 'Creates small anonymous functions in a single expression. Can only contain one expression.', example: '# Basic lambda\nsquare = lambda x: x ** 2\nprint(square(5))  # 25\n\n# As argument\nnums = [3, 1, 4, 1, 5]\nprint(sorted(nums, key=lambda x: -x))  # [5, 4, 3, 1, 1]\n\n# Multiple args\nadd = lambda a, b: a + b\nprint(add(3, 4))  # 7\n\n# In map/filter\nprint(list(map(lambda x: x*2, [1,2,3])))  # [2, 4, 6]\nprint(list(filter(lambda x: x>2, [1,2,3,4])))  # [3, 4]', edgeCases: ['Lambda is limited to a single expression (no statements, no assignments).', 'Use def for complex logic.'], tags: ['lambda', 'anonymous', 'inline', 'functional'] },
        { id: 'fn-global-nonlocal', name: 'global / nonlocal', signature: 'global var | nonlocal var', description: 'global declares a variable as global scope. nonlocal refers to the enclosing (not global) scope.', example: 'count = 0\n\ndef increment():\n    global count\n    count += 1\n\nincrement()\nprint(count)  # 1\n\n# nonlocal for closures\ndef outer():\n    x = 10\n    def inner():\n        nonlocal x\n        x += 1\n    inner()\n    print(x)  # 11\n\nouter()', edgeCases: ['Without global/nonlocal, assignment creates a new local variable.', 'Reading without assignment uses LEGB.'], tags: ['scope', 'global', 'nonlocal', 'modify'] },
        { id: 'fn-type-hints', name: 'Type Hints', signature: 'def func(param: type) -> return_type:', description: 'Type annotations for documentation and static analysis. Not enforced at runtime.', example: 'def greet(name: str, times: int = 1) -> str:\n    return (f"Hello, {name}! " * times).strip()\n\nprint(greet("Alice", 2))\n\n# Complex types\nfrom typing import List, Dict, Optional, Tuple\n\ndef process(items: List[int]) -> Dict[str, int]:\n    return {"sum": sum(items), "count": len(items)}\n\ndef find(items: List[str], target: str) -> Optional[int]:\n    try:\n        return items.index(target)\n    except ValueError:\n        return None', edgeCases: ['Type hints are NOT enforced at runtime.', 'Use mypy for static checking.'], tags: ['typing', 'annotation', 'documentation'] },
        { id: 'fn-recursion', name: 'Recursion', signature: 'def func(): ... func() ...', description: 'A function that calls itself. Must have a base case to prevent infinite recursion.', example: '# Factorial\ndef factorial(n):\n    if n <= 1:      # Base case\n        return 1\n    return n * factorial(n - 1)  # Recursive case\n\nprint(factorial(5))  # 120\n\n# Fibonacci\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)\n\nprint(fib(10))  # 55', edgeCases: ['Python default recursion limit is 1000. Use sys.setrecursionlimit() to change.', 'Prefer iteration for deep recursion.'], tags: ['recursion', 'self-call', 'base-case'] },

        { id: 'fn-docstrings', name: 'Docstrings', signature: '"""Description."""', description: 'First string in a function/class/module. Stored as __doc__ attribute. Used by help().', example: 'def calculate_area(radius: float) -> float:\n    """Calculate the area of a circle.\n\n    Args:\n        radius: The radius of the circle.\n\n    Returns:\n        The area as a float.\n\n    Raises:\n        ValueError: If radius is negative.\n    """\n    if radius < 0:\n        raise ValueError("Negative radius")\n    return 3.14159 * radius ** 2\n\nprint(calculate_area.__doc__)\nhelp(calculate_area)', tags: ['documentation', 'docstring', 'help'] },
        { id: 'fn-first-class', name: 'Functions as First-Class Objects', signature: 'N/A', description: 'Functions can be assigned to variables, passed as arguments, returned from functions, and stored in data structures.', example: '# Assign to variable\ndef shout(text):\n    return text.upper()\n\nyell = shout\nprint(yell("hello"))  # HELLO\n\n# Pass as argument\ndef apply(func, value):\n    return func(value)\n\nprint(apply(len, "hello"))   # 5\nprint(apply(sorted, [3,1,2])) # [1, 2, 3]\n\n# Store in list\nops = [str.upper, str.lower, str.title]\nfor op in ops:\n    print(op("hello World"))  # HELLO WORLD, hello world, Hello World', tags: ['first-class', 'higher-order', 'functional'] },
        { id: 'fn-positional-only', name: 'Positional-Only Arguments', signature: 'def func(pos_only, /, normal)', description: 'Parameters before / must be passed positionally (not as keyword). (3.8+)', example: 'def greet(name, /, greeting="Hello"):\n    return f"{greeting}, {name}!"\n\nprint(greet("Alice"))              # Hello, Alice!\nprint(greet("Alice", greeting="Hi")) # Hi, Alice!\n# greet(name="Alice")  ← TypeError!', tags: ['positional', 'parameter', 'api-design'] },
        { id: 'fn-unpacking-args', name: 'Argument Unpacking', signature: 'func(*list) | func(**dict)', description: 'Unpack a list/tuple into positional args or a dict into keyword args when calling a function.', example: 'def add(a, b, c):\n    return a + b + c\n\nnums = [1, 2, 3]\nprint(add(*nums))  # 6\n\nparams = {"a": 10, "b": 20, "c": 30}\nprint(add(**params))  # 60', tags: ['unpacking', 'spread', 'call'] },
    ]
};
