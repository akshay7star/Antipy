import { Category } from '../types';

export const pythonKeywords: Category = {
    id: 'python-keywords',
    name: 'Python Keywords',
    description: 'All 35 Python keywords â€” reserved words with special meaning that cannot be used as identifiers',
    icon: 'Key',
    entries: [
        { id: 'kw-false', name: 'False', signature: 'False', description: 'Boolean constant representing falsy value. One of two boolean literals.', example: 'x = False\nprint(type(x))     # <class \'bool\'>\nprint(False == 0)   # True\nprint(False + 1)    # 1', tags: ['boolean', 'literal', 'constant'] },
        { id: 'kw-none', name: 'None', signature: 'None', description: 'The null value in Python. Represents absence of a value. Returned by functions without explicit return.', example: 'x = None\nprint(x is None)    # True (use "is" not "==")\nprint(type(None))    # <class \'NoneType\'>\n\ndef no_return():\n    pass\n\nresult = no_return()\nprint(result)  # None', edgeCases: ['Always use "is None" and "is not None", never "== None".'], tags: ['null', 'none', 'absence'] },
        { id: 'kw-is', name: 'is', signature: 'a is b', description: 'Identity comparison. True if both operands refer to the same object in memory.', example: 'a = [1, 2]\nb = a\nc = [1, 2]\nprint(a is b)     # True (same object)\nprint(a is c)     # False (different objects)\nprint(a is None)  # Common pattern', edgeCases: ['Use "is" only for None/True/False.', 'Use "==" for value comparison.'], tags: ['identity', 'reference', 'object'] },

        { id: 'kw-lambda', name: 'lambda', signature: 'lambda params: expression', description: 'Creates a small anonymous function. Limited to a single expression.', example: 'square = lambda x: x ** 2\nprint(square(5))  # 25\n\n# Common use: sort key\npoints = [(1,3), (2,1), (3,2)]\npoints.sort(key=lambda p: p[1])\nprint(points)  # [(2,1), (3,2), (1,3)]', tags: ['anonymous', 'function', 'inline'] },
        { id: 'kw-nonlocal', name: 'nonlocal', signature: 'nonlocal variable_name', description: 'Refers to a variable in the enclosing (not global) function scope.', example: 'def outer():\n    x = 10\n    def inner():\n        nonlocal x\n        x += 1\n    inner()\n    print(x)  # 11\n\nouter()', tags: ['scope', 'enclosing', 'closure'] },
        { id: 'kw-not', name: 'not', signature: 'not expression', description: 'Logical NOT. Returns True if expression is falsy.', example: 'print(not True)      # False\nprint(not 0)         # True\nprint(not [])        # True\nprint(not "hello")   # False', tags: ['logical', 'negate', 'boolean'] },
        { id: 'kw-or', name: 'or', signature: 'a or b', description: 'Logical OR. Returns first truthy value or last value. Short-circuits.', example: 'print(False or True)     # True\nprint(0 or "default")    # "default"\nprint(None or [] or 0)   # 0 (last value)', tags: ['logical', 'operator', 'default'] },
        { id: 'kw-pass', name: 'pass', signature: 'pass', description: 'No-operation placeholder. Used where syntax requires a statement but no action is needed.', example: 'class Todo:\n    pass\n\ndef not_implemented():\n    pass\n\nif True:\n    pass  # Will fill in later', tags: ['placeholder', 'noop', 'stub'] },
        { id: 'kw-raise', name: 'raise', signature: 'raise ExceptionType("message")', description: 'Raises an exception. Can raise built-in or custom exceptions.', example: 'raise ValueError("Invalid input")\n\n# Re-raise\ntry:\n    risky()\nexcept Exception:\n    print("logging...")\n    raise  # Re-raises same exception', tags: ['exception', 'throw', 'error'] },
        { id: 'kw-return', name: 'return', signature: 'return [expression]', description: 'Exits function and returns a value. Without expression, returns None.', example: 'def add(a, b):\n    return a + b\n\ndef early_exit(x):\n    if x < 0:\n        return  # Returns None\n    return x ** 2', tags: ['function', 'output', 'exit'] },
        { id: 'kw-try', name: 'try', signature: 'try: ... except: ... else: ... finally: ...', description: 'Starts an exception-handling block.', example: 'try:\n    result = int("abc")\nexcept ValueError:\n    print("Not a number")\nelse:\n    print(f"Got: {result}")\nfinally:\n    print("Done")', tags: ['exception', 'handle', 'catch'] },
        { id: 'kw-while', name: 'while', signature: 'while condition: ...', description: 'Repeats a block while condition is True.', example: 'n = 5\nwhile n > 0:\n    print(n)\n    n -= 1\n# 5, 4, 3, 2, 1', tags: ['loop', 'condition', 'repeat'] },
        { id: 'kw-with', name: 'with', signature: 'with expression as variable: ...', description: 'Context manager statement. Ensures cleanup (calls __exit__) even if errors occur.', example: 'with open("file.txt") as f:\n    content = f.read()\n# File automatically closed\n\n# Multiple context managers\nwith open("in.txt") as src, open("out.txt", "w") as dst:\n    dst.write(src.read())', tags: ['context-manager', 'cleanup', 'resource'] },
        { id: 'kw-yield', name: 'yield', signature: 'yield [expression]', description: 'Pauses a generator function and produces a value. Resumes on next call.', example: 'def count_up(n):\n    i = 0\n    while i < n:\n        yield i\n        i += 1\n\nfor num in count_up(3):\n    print(num)  # 0, 1, 2', tags: ['generator', 'lazy', 'produce'] },
    ]
};
