import { Category } from '../types';

export const booleanOps: Category = {
    id: 'boolean-operations',
    name: 'Boolean Operations',
    description: 'Truthiness rules, bool conversion, short-circuit evaluation, and comparison chaining',
    icon: 'ToggleRight',
    entries: [
        { id: 'bool-truthiness', name: 'Truthiness Rules', signature: 'N/A', description: 'Python evaluates any value as True or False. Falsy values: 0, 0.0, "", [], (), {}, set(), None, False. Everything else is truthy.', example: '# Falsy values\nprint(bool(0))       # False\nprint(bool(""))      # False\nprint(bool([]))      # False\nprint(bool(None))    # False\n\n# Truthy values\nprint(bool(1))       # True\nprint(bool("hi"))    # True\nprint(bool([0]))     # True (non-empty list!)\nprint(bool(-1))      # True (non-zero!)', edgeCases: ['bool([0]) is True (non-empty list).', 'bool(-1) is True (non-zero).', 'bool(" ") is True (non-empty).'], tags: ['truthiness', 'falsy', 'truthy'] },
        { id: 'bool-conversion', name: 'bool() Conversion', signature: 'bool(x) -> bool', description: 'Converts any value to its boolean equivalent by calling __bool__ or __len__.', example: 'class MyClass:\n    def __bool__(self):\n        return False\n\nobj = MyClass()\nprint(bool(obj))  # False\n\n# Classes with __len__\nclass Bag:\n    def __init__(self, items):\n        self.items = items\n    def __len__(self):\n        return len(self.items)\n\nprint(bool(Bag([])))     # False (len=0)\nprint(bool(Bag([1])))    # True (len=1)', tags: ['conversion', 'bool', 'dunder'] },
        { id: 'bool-short-circuit', name: 'Short-Circuit Evaluation', signature: 'x and y | x or y', description: 'Python stops evaluating as soon as the result is determined. "and" stops at first falsy, "or" stops at first truthy.', example: '# and: stops at first falsy\ndef side_effect():\n    print("called!")\n    return True\n\nresult = False and side_effect()  # "called!" NOT printed\nprint(result)  # False\n\n# or: stops at first truthy\nresult = True or side_effect()   # "called!" NOT printed\nprint(result)  # True\n\n# Practical use: guard pattern\nuser = None\nname = user and user.name  # Safe, won\'t crash', edgeCases: ['Returns actual values, not True/False.', '0 or "default" returns "default".'], tags: ['short-circuit', 'lazy', 'optimization'] },
        { id: 'bool-chaining', name: 'Comparison Chaining', signature: 'a < b < c', description: 'Python allows chaining comparisons, which is equivalent to (a < b) and (b < c) but evaluates b only once.', example: 'x = 5\nprint(1 < x < 10)      # True\nprint(1 < x > 3)       # True\nprint(0 <= x <= 10)    # True\n\n# Equivalent to:\nprint(1 < x and x < 10)  # True\n\n# Works with any comparison\na, b, c = 1, 2, 3\nprint(a < b < c)    # True\nprint(a == b == c)  # False', tags: ['comparison', 'chaining', 'range'] },
        { id: 'bool-is-true-false', name: 'True/False as Integers', signature: 'True == 1, False == 0', description: 'In Python, bool is a subclass of int. True is 1, False is 0.', example: 'print(True + True)     # 2\nprint(True * 10)       # 10\nprint(False + 1)       # 1\nprint(sum([True, True, False, True]))  # 3\n\n# Count truthy items\nnums = [1, 0, 3, 0, 5]\ncount = sum(bool(x) for x in nums)\nprint(count)  # 3', edgeCases: ['This means {True: "a", 1: "b"} has only one key: {True: "b"} because True == 1.'], tags: ['bool', 'int', 'arithmetic', 'gotcha'] },
    ]
};
