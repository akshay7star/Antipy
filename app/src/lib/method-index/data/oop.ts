import { Category } from '../types';

export const oop: Category = {
    id: 'oop',
    name: 'Object-Oriented Programming',
    description: 'Classes, inheritance, dunder methods, properties, dataclasses, abstract base classes, and more',
    icon: 'Boxes',
    entries: [
        { id: 'oop-class', name: 'class', signature: 'class ClassName: ...', description: 'Defines a new class — a blueprint for creating objects with shared attributes and methods.', example: 'class Dog:\n    species = "Canis familiaris"  # Class attribute\n\n    def __init__(self, name, age):\n        self.name = name  # Instance attribute\n        self.age = age\n\n    def bark(self):\n        return f"{self.name} says Woof!"\n\ndog = Dog("Rex", 3)\nprint(dog.bark())  # Rex says Woof!', tags: ['class', 'define', 'object'] },
        { id: 'oop-init', name: '__init__()', signature: 'def __init__(self, ...): ...', description: 'The constructor method. Called automatically when creating a new instance.', example: 'class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\np = Person("Alice", 30)\nprint(p.name, p.age)  # Alice 30', edgeCases: ['__init__ initializes the object.', '__new__ actually creates it (rarely overridden).'], tags: ['constructor', 'init', 'create'] },
        { id: 'oop-self', name: 'self', signature: 'def method(self, ...): ...', description: 'Refers to the current instance. Must be the first parameter of instance methods.', example: 'class Counter:\n    def __init__(self):\n        self.count = 0\n\n    def increment(self):\n        self.count += 1\n        return self  # Enable chaining\n\nc = Counter()\nc.increment().increment().increment()\nprint(c.count)  # 3', edgeCases: ['"self" is a convention, not a keyword.', 'You could use any name, but always use "self".'], tags: ['self', 'instance', 'reference'] },
        { id: 'oop-slots', name: '__slots__', signature: '__slots__ = ["attr1", "attr2"]', description: 'Restricts instance attributes to a fixed set. Saves memory and prevents typos.', example: 'class Point:\n    __slots__ = ["x", "y"]\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\np = Point(1, 2)\nprint(p.x)    # 1\n# p.z = 3     ← AttributeError! (no __dict__)', edgeCases: ['Objects with __slots__ don\'t have __dict__, saving ~40% memory for many instances.'], tags: ['slots', 'memory', 'restrict'] },

        { id: 'oop-class-method', name: '@classmethod', signature: '@classmethod def method(cls, ...): ...', description: 'Method that receives the class (not instance) as first argument. Used for alternative constructors.', example: 'class Date:\n    def __init__(self, year, month, day):\n        self.year = year\n        self.month = month\n        self.day = day\n\n    @classmethod\n    def from_string(cls, date_str):\n        y, m, d = date_str.split("-")\n        return cls(int(y), int(m), int(d))\n\nd = Date.from_string("2024-01-15")\nprint(d.year)  # 2024', tags: ['classmethod', 'factory', 'alternative-constructor'] },
        { id: 'oop-static-method', name: '@staticmethod', signature: '@staticmethod def method(...): ...', description: 'Method that doesn\'t receive self or cls. Belongs to the class namespace but doesn\'t access instance or class.', example: 'class MathUtils:\n    @staticmethod\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\nprint(MathUtils.is_prime(17))  # True\nprint(MathUtils.is_prime(4))   # False', tags: ['static', 'utility', 'no-self'] },
        { id: 'oop-multiple-inheritance', name: 'Multiple Inheritance', signature: 'class Child(Parent1, Parent2): ...', description: 'A class can inherit from multiple parent classes. Python uses MRO (C3 linearization) to resolve conflicts.', example: 'class Flying:\n    def move(self):\n        return "flying"\n\nclass Swimming:\n    def move(self):\n        return "swimming"\n\nclass Duck(Flying, Swimming):\n    pass\n\nd = Duck()\nprint(d.move())  # flying (first parent wins)\n\n# Mixin pattern\nclass LogMixin:\n    def log(self, msg):\n        print(f"[{self.__class__.__name__}] {msg}")\n\nclass Server(LogMixin):\n    def start(self):\n        self.log("Server started")\n\nServer().start()  # [Server] Server started', tags: ['multiple', 'inheritance', 'mixin', 'diamond'] },
        { id: 'oop-namedtuple-typing', name: 'typing.NamedTuple', signature: 'class Point(NamedTuple): ...', description: 'Type-annotated alternative to collections.namedtuple. Cleaner syntax. (3.6+)', example: 'from typing import NamedTuple\n\nclass Point(NamedTuple):\n    x: float\n    y: float\n    label: str = "origin"\n\np = Point(3, 4)\nprint(p.x, p.y)      # 3 4\nprint(p[0])           # 3 (still a tuple!)\nprint(p._asdict())    # {\'x\': 3, \'y\': 4, \'label\': \'origin\'}', tags: ['namedtuple', 'typed', 'immutable'] },
    ]
};
