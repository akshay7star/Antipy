import { Category } from '../types';

export const regex: Category = {
    id: 'regex',
    name: 'Regular Expressions',
    description: 'Pattern matching with the re module — search, match, sub, findall, groups, and common patterns',
    icon: 'Search',
    entries: [
        { id: 're-search', name: 're.search()', signature: 're.search(pattern, string, flags=0) -> Match | None', description: 'Searches entire string for the first match of pattern. Returns Match object or None.', example: 'import re\n\nresult = re.search(r"\\d+", "Order #1234 placed")\nif result:\n    print(result.group())  # 1234\n    print(result.start())  # 7\n    print(result.end())    # 11', tags: ['search', 'find', 'first'] },
        { id: 're-match', name: 're.match()', signature: 're.match(pattern, string) -> Match | None', description: 'Matches pattern at the BEGINNING of the string only.', example: 'import re\n\nprint(re.match(r"\\d+", "123abc"))   # Match (starts with digits)\nprint(re.match(r"\\d+", "abc123"))   # None (doesn\'t start with digits)\n\n# Use ^ with search for same behavior:\nprint(re.search(r"^\\d+", "abc123"))  # None', edgeCases: ['re.match only checks the start.', 'Use re.search for anywhere in string.', 'Use re.fullmatch for entire string.'], tags: ['match', 'start', 'beginning'] },

        { id: 're-findall', name: 're.findall()', signature: 're.findall(pattern, string) -> list[str]', description: 'Returns ALL non-overlapping matches as a list of strings.', example: 'import re\n\nprint(re.findall(r"\\d+", "3 cats, 5 dogs, 2 birds"))\n# [\'3\', \'5\', \'2\']\n\nprint(re.findall(r"[a-z]+@[a-z]+\\.com", "alice@mail.com and bob@work.com"))\n# [\'alice@mail.com\', \'bob@work.com\']\n\n# With groups — returns tuples\nprint(re.findall(r"(\\w+)@(\\w+)", "alice@mail bob@work"))\n# [(\'alice\', \'mail\'), (\'bob\', \'work\')]', tags: ['findall', 'all', 'list'] },
        { id: 're-sub', name: 're.sub()', signature: 're.sub(pattern, replacement, string, count=0) -> str', description: 'Replace all matches of pattern with replacement string.', example: 'import re\n\n# Simple replacement\nprint(re.sub(r"\\d+", "X", "Order 123, Item 456"))\n# "Order X, Item X"\n\n# Replace with function\ndef double(match):\n    return str(int(match.group()) * 2)\n\nprint(re.sub(r"\\d+", double, "3 cats and 5 dogs"))\n# "6 cats and 10 dogs"\n\n# Backreferences\nprint(re.sub(r"(\\w+) (\\w+)", r"\\2 \\1", "Hello World"))\n# "World Hello"', tags: ['replace', 'substitute', 'transform'] },
        { id: 're-split', name: 're.split()', signature: 're.split(pattern, string, maxsplit=0) -> list', description: 'Split string by pattern matches.', example: 'import re\n\nprint(re.split(r"[,;\\s]+", "a,b; c  d"))\n# [\'a\', \'b\', \'c\', \'d\']\n\nprint(re.split(r"(\\d+)", "foo123bar456baz"))\n# [\'foo\', \'123\', \'bar\', \'456\', \'baz\']', tags: ['split', 'tokenize', 'separate'] },
        { id: 're-groups', name: 'Groups & Named Groups', signature: '(pattern) | (?P<name>pattern)', description: 'Capture parts of a match with parentheses. Access by number or name.', example: 'import re\n\n# Numbered groups\nm = re.search(r"(\\d{4})-(\\d{2})-(\\d{2})", "Date: 2024-01-15")\nprint(m.group(0))   # 2024-01-15 (full match)\nprint(m.group(1))   # 2024 (year)\nprint(m.groups())   # (\'2024\', \'01\', \'15\')\n\n# Named groups\nm = re.search(r"(?P<year>\\d{4})-(?P<month>\\d{2})-(?P<day>\\d{2})", "2024-01-15")\nprint(m.group("year"))   # 2024\nprint(m.groupdict())     # {\'year\': \'2024\', \'month\': \'01\', \'day\': \'15\'}', tags: ['group', 'capture', 'named'] },
        { id: 're-compile', name: 're.compile()', signature: 're.compile(pattern, flags=0) -> Pattern', description: 'Pre-compile a regex pattern for reuse. More efficient when using the same pattern many times.', example: 'import re\n\nemail_pattern = re.compile(r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}")\n\nemails = [\n    "alice@example.com",\n    "not-an-email",\n    "bob@work.org"\n]\n\nvalid = [e for e in emails if email_pattern.match(e)]\nprint(valid)  # [\'alice@example.com\', \'bob@work.org\']', tags: ['compile', 'reuse', 'efficient'] },
        { id: 're-flags', name: 'Regex Flags', signature: 're.IGNORECASE | re.MULTILINE | re.DOTALL | re.VERBOSE', description: 'Modify how patterns match with flags.', example: 'import re\n\n# Case insensitive\nprint(re.findall(r"python", "Python PYTHON python", re.IGNORECASE))\n# [\'Python\', \'PYTHON\', \'python\']\n\n# Multiline (^ and $ match line boundaries)\ntext = "line1\\nline2\\nline3"\nprint(re.findall(r"^line\\d", text, re.MULTILINE))\n# [\'line1\', \'line2\', \'line3\']\n\n# Verbose (allow comments and whitespace)\nphone = re.compile(r"""\n    (\\d{3})   # Area code\n    [-.]?      # Separator\n    (\\d{3})   # Exchange\n    [-.]?      # Separator\n    (\\d{4})   # Number\n""", re.VERBOSE)', tags: ['flags', 'options', 'case'] },
        { id: 're-patterns', name: 'Common Patterns', signature: 'N/A', description: 'Essential regex patterns for common tasks.', example: 'import re\n\n# Email\nemail = r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}"\n\n# Phone (US)\nphone = r"\\(?\\d{3}\\)?[-.\\s]?\\d{3}[-.\\s]?\\d{4}"\n\n# URL\nurl = r"https?://[\\w.-]+(?:\\.[\\w]+)+[\\w.,@?^=%&:/~+#-]*"\n\n# IPv4\nipv4 = r"\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b"\n\n# Date (YYYY-MM-DD)\ndate = r"\\d{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\\d|3[01])"\n\n# Password (8+ chars, upper, lower, digit, special)\npassword = r"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$"', tags: ['common', 'email', 'phone', 'url', 'reference'] },
        { id: 're-syntax', name: 'Regex Syntax Reference', signature: 'N/A', description: 'Complete regex syntax cheatsheet.', example: '# Character classes\n# .     Any character (except newline)\n# \\d    Digit [0-9]\n# \\D    Non-digit\n# \\w    Word char [a-zA-Z0-9_]\n# \\W    Non-word char\n# \\s    Whitespace [ \\t\\n\\r]\n# \\S    Non-whitespace\n# [abc] Set: a, b, or c\n# [^abc] Not a, b, or c\n# [a-z] Range: a to z\n\n# Quantifiers\n# *     0 or more\n# +     1 or more\n# ?     0 or 1\n# {n}   Exactly n\n# {n,m} Between n and m\n# *?    Non-greedy (lazy)\n\n# Anchors\n# ^     Start of string\n# $     End of string\n# \\b    Word boundary\n\n# Groups\n# ()      Capturing group\n# (?:)    Non-capturing group\n# (?=)    Lookahead\n# (?<=)   Lookbehind', tags: ['syntax', 'cheatsheet', 'reference'] },
    ]
};
