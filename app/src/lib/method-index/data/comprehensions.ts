import { Category } from '../types';

export const comprehensions: Category = {
    id: 'comprehensions-generators',
    name: 'Comprehensions & Generators',
    description: 'List/dict/set comprehensions, generator expressions, yield, itertools, and lazy evaluation',
    icon: 'Repeat',
    entries: [
        { id: 'comp-list', name: 'List Comprehension', signature: '[expr for item in iterable if condition]', description: 'Create lists with a concise, readable single-line syntax. Faster than equivalent for loops.', example: 'squares = [x**2 for x in range(10)]\nprint(squares)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\nevens = [x for x in range(20) if x % 2 == 0]\nprint(evens)  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]', tags: ['comprehension', 'list', 'create'] },
        { id: 'comp-dict', name: 'Dict Comprehension', signature: '{key: value for item in iterable if condition}', description: 'Create dictionaries with a concise syntax.', example: 'squares = {x: x**2 for x in range(5)}\nprint(squares)  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\n\n# Invert a dictionary\noriginal = {"a": 1, "b": 2, "c": 3}\ninverted = {v: k for k, v in original.items()}\nprint(inverted)  # {1: \'a\', 2: \'b\', 3: \'c\'}', tags: ['comprehension', 'dict', 'create'] },
        { id: 'comp-set', name: 'Set Comprehension', signature: '{expr for item in iterable if condition}', description: 'Create sets (auto-deduplicated) with comprehension syntax.', example: 'text = "hello world"\nvowels = {c for c in text if c in "aeiou"}\nprint(vowels)  # {\'e\', \'o\'}\n\nabs_vals = {abs(x) for x in [-3, -1, 0, 1, 3]}\nprint(abs_vals)  # {0, 1, 3}', tags: ['comprehension', 'set', 'unique'] },
        { id: 'comp-nested', name: 'Nested Comprehensions', signature: '[expr for outer in iterable for inner in iterable]', description: 'Flatten nested structures or create combinations using multiple for clauses.', example: '# Flatten 2D list\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nflat = [x for row in matrix for x in row]\nprint(flat)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# All combinations\ncolors = ["red", "blue"]\nsizes = ["S", "M", "L"]\ncombos = [(c, s) for c in colors for s in sizes]\nprint(combos)\n# [(\'red\', \'S\'), (\'red\', \'M\'), (\'red\', \'L\'), (\'blue\', \'S\'), ...]', tags: ['nested', 'flatten', 'combination'] },
        { id: 'comp-conditional', name: 'Conditional Comprehensions', signature: '[a if condition else b for item in iterable]', description: 'Use if/else inside comprehensions for transforming values conditionally.', example: '# if/else expression (transforms every item)\nlabels = ["even" if x % 2 == 0 else "odd" for x in range(5)]\nprint(labels)  # [\'even\', \'odd\', \'even\', \'odd\', \'even\']\n\n# filter (only if at end)\nevens = [x for x in range(10) if x % 2 == 0]\nprint(evens)  # [0, 2, 4, 6, 8]', edgeCases: ['if at END = filter.', 'if/else BEFORE for = transform.', 'They are different!'], tags: ['conditional', 'filter', 'transform'] },
        { id: 'gen-yield', name: 'yield (Generators)', signature: 'def gen(): yield value', description: 'Creates a generator function that yields values lazily one at a time, saving memory.', example: 'def countdown(n):\n    while n > 0:\n        yield n\n        n -= 1\n\nfor num in countdown(5):\n    print(num)  # 5, 4, 3, 2, 1\n\n# Infinite generator\ndef fibonacci():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\nfib = fibonacci()\nfor _ in range(8):\n    print(next(fib))  # 0, 1, 1, 2, 3, 5, 8, 13', edgeCases: ['Generator functions return generator objects.', 'They pause at yield and resume on next().'], tags: ['generator', 'yield', 'lazy'] },
        { id: 'gen-yield-from', name: 'yield from', signature: 'yield from iterable', description: 'Delegates generation to a sub-generator or iterable. Simplifies nested generators.', example: 'def flatten(nested):\n    for item in nested:\n        if isinstance(item, list):\n            yield from flatten(item)  # Recursive delegation\n        else:\n            yield item\n\nnested = [1, [2, 3], [4, [5, 6]]]\nprint(list(flatten(nested)))  # [1, 2, 3, 4, 5, 6]', tags: ['yield-from', 'delegate', 'recursive'] },
        { id: 'gen-expression', name: 'Generator Expression', signature: '(expr for item in iterable if condition)', description: 'Like list comprehension but creates a lazy generator. Uses () instead of []. Memory efficient.', example: '# Generator (lazy)\ngen = (x**2 for x in range(1000000))\nprint(next(gen))  # 0\nprint(next(gen))  # 1\n# Only computes values on demand!\n\n# As function argument (parentheses optional)\nprint(sum(x**2 for x in range(10)))  # 285\nprint(max(len(w) for w in ["hi", "hello", "hey"]))  # 5', edgeCases: ['Generator expressions can only be iterated ONCE.', 'List comprehensions create reusable lists.'], tags: ['generator', 'lazy', 'memory'] },
        { id: 'gen-itertools', name: 'itertools Module', signature: 'import itertools', description: 'Standard library module with powerful iterator building blocks.', example: 'import itertools\n\n# Chain iterables together\nprint(list(itertools.chain([1,2], [3,4], [5])))\n# [1, 2, 3, 4, 5]\n\n# Repeat\nprint(list(itertools.repeat("ha", 3)))  # [\'ha\', \'ha\', \'ha\']\n\n# Combinations and permutations\nprint(list(itertools.combinations("ABC", 2)))\n# [(\'A\',\'B\'), (\'A\',\'C\'), (\'B\',\'C\')]\n\nprint(list(itertools.permutations("AB", 2)))\n# [(\'A\',\'B\'), (\'B\',\'A\')]\n\n# Count infinitely\nfor i in itertools.islice(itertools.count(10, 2), 5):\n    print(i)  # 10, 12, 14, 16, 18\n\n# Group by\ndata = sorted(["apple", "avocado", "banana", "blueberry"], key=lambda x: x[0])\nfor key, group in itertools.groupby(data, key=lambda x: x[0]):\n    print(f"{key}: {list(group)}")', tags: ['itertools', 'combinatorics', 'chain', 'tools'] },
        { id: 'gen-send', name: 'Generator send()', signature: 'generator.send(value)', description: 'Sends a value INTO a running generator, resumed at the yield point.', example: 'def accumulator():\n    total = 0\n    while True:\n        value = yield total\n        if value is None:\n            break\n        total += value\n\nacc = accumulator()\nnext(acc)            # Initialize (must call next first)\nprint(acc.send(10))  # 10\nprint(acc.send(20))  # 30\nprint(acc.send(5))   # 35', edgeCases: ['Must call next() once before send().', 'send(None) is equivalent to next().'], tags: ['send', 'coroutine', 'advanced'] },
    ]
};
