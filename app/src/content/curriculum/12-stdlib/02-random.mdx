---
title: "Random & Probability"
description: "Generating random data, shuffling, and simulations."
order: 2
---

# The Random Module

<StdlibVisualizer />

The `random` module is essential for games, simulations, testing, and any scenario where you need unpredictable data. Python's random numbers are *pseudo-random* — they follow a deterministic algorithm but appear random for practical purposes.

## Core Functions

| Function | Purpose | Example |
|----------|---------|---------|
| `random()` | Float between 0 and 1 | `random.random()` → `0.7423` |
| `randint(a, b)` | Integer from a to b (inclusive) | `randint(1, 6)` → dice roll |
| `choice(seq)` | Random item from sequence | `choice(["a","b"])` |
| `choices(seq, k)` | Multiple random items (with replacement) | `choices(colors, k=3)` |
| `sample(seq, k)` | Multiple items (without replacement) | `sample(range(50), k=6)` |
| `shuffle(list)` | Shuffle list in place | `shuffle(deck)` |
| `uniform(a, b)` | Float between a and b | `uniform(1.0, 10.0)` |

### Practice: Random Operations

<interactive-code>
import random

# Dice roller
rolls = [random.randint(1, 6) for _ in range(10)]
print(f"Dice rolls: {rolls}")

# Random password generator
chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$"
password = "".join(random.choices(chars, k=12))
print(f"Password: {password}")

# Lottery numbers (6 unique from 1-49)
lottery = sorted(random.sample(range(1, 50), 6))
print(f"Lottery: {lottery}")

# Shuffle a deck
cards = [f"{r}{s}" for r in "A23456789TJQK" for s in "♠♥♦♣"]
random.shuffle(cards)
print(f"Top 5 cards: {cards[:5]}")
</interactive-code>

## Weighted Random Choices

Not all options need equal probability:

### Practice: Weighted Simulation

<interactive-code>
import random

# Weighted loot drops in a game
loot_table = ["Common", "Uncommon", "Rare", "Epic", "Legendary"]
weights = [50, 30, 15, 4, 1]  # Relative probabilities

drops = random.choices(loot_table, weights=weights, k=20)

print("Loot drops (20 runs):")
for item in set(drops):
    count = drops.count(item)
    bar = "█" * count
    print(f"  {item:12} {bar} ({count})")
</interactive-code>

## Reproducible Random with Seeds

Setting a **seed** makes random results reproducible — essential for testing and debugging:

```python
random.seed(42)           # Same seed = same results every time
print(random.randint(1, 100))  # Always 82 with seed 42
```

> **Pro Tip:** For security-sensitive randomness (passwords, tokens), use `secrets` module instead of `random`: `secrets.token_hex(16)` produces cryptographically secure random data.

> **Common Mistake:** Using `random` for security (passwords, session tokens). Python's `random` is predictable if the seed is known. Use `secrets` module for anything security-related.

<InlineQuiz
  id="quiz-random-1"
  question="Why should you NOT use the 'random' module for passwords or security tokens?"
  options={["It is too slow", "It generates the same numbers every time", "It uses a predictable algorithm that can be reverse-engineered", "It only works with integers"]}
  correct={2}
  explanation="The 'random' module uses a pseudo-random number generator (Mersenne Twister) that is deterministic � given the seed, all future values can be predicted. For security, use the 'secrets' module instead."
/>

<InlineQuiz id="quiz-rand-2" question="What does random.randint(1, 10) return?" options={["A random float from 1 to 10", "A random integer from 1 to 10, inclusive", "A random integer from 1 to 9", "Always 1 or 10"]} correct={1} explanation="randint(a, b) returns a random integer N such that a <= N <= b. Both endpoints are inclusive." />

<InlineQuiz id="quiz-rand-3" question="What does random.choice([1, 2, 3]) do?" options={["Returns all elements", "Returns one random element", "Shuffles the list", "Returns the first element"]} correct={1} explanation="choice() picks one random element from a non-empty sequence. Each element has equal probability." />

<InlineQuiz id="quiz-rand-4" question="What does random.shuffle(my_list) return?" options={["A new shuffled list", "None (shuffles in place)", "The original list", "An error"]} correct={1} explanation="shuffle() modifies the list IN PLACE and returns None. To get a new shuffled list without modifying the original, use random.sample(my_list, len(my_list))." />

<InlineQuiz id="quiz-rand-5" question="What does random.random() return?" options={["A random integer", "A random float between 0.0 and 1.0", "True or False", "A random string"]} correct={1} explanation="random.random() returns a random float in [0.0, 1.0). The upper bound 1.0 is excluded." />

<InlineQuiz id="quiz-rand-6" question="What is a seed in random number generation?" options={["A type of error", "An initial value that determines the sequence of random numbers", "A random string", "A loop counter"]} correct={1} explanation="A seed initializes the random number generator. Same seed = same sequence of random numbers. Useful for reproducible results." />

<InlineQuiz id="quiz-rand-7" question="What does random.sample(population, k) do?" options={["Returns k random elements WITH replacement", "Returns k random elements WITHOUT replacement", "Returns the first k elements", "Shuffles and returns k elements"]} correct={1} explanation="sample() returns k unique elements (without replacement). For sampling WITH replacement, use random.choices()." />

<InlineQuiz id="quiz-rand-8" question="What module should you use for cryptographic randomness?" options={["random", "secrets", "crypto", "hashlib"]} correct={1} explanation="The secrets module provides cryptographically strong random numbers suitable for passwords, tokens, and security-sensitive applications." />

<InlineQuiz id="quiz-rand-9" question="What does random.uniform(1.0, 5.0) return?" options={["An integer between 1 and 5", "A random float between 1.0 and 5.0", "Always 3.0", "A list of floats"]} correct={1} explanation="uniform(a, b) returns a random float N such that a <= N <= b. Unlike random(), you can specify the range." />

<InlineQuiz id="quiz-rand-10" question="What does random.choices(population, k=3) do vs sample?" options={["Same thing", "choices allows repeats, sample doesn&apos;t", "sample allows repeats, choices doesn&apos;t", "choices is faster"]} correct={1} explanation="choices() selects WITH replacement (can pick the same element multiple times). sample() selects WITHOUT replacement (each element picked at most once)." />
