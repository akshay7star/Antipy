---
title: "Imports & Packages"
description: "Organizing code with modules, packages, and the import system."
order: 1
---

# Modules: Organizing Your Code

As your programs grow, you can't keep everything in one file. Modules let you split your code into separate files and import functionality from one file into another. This is how every real Python project is organized.

## What Is a Module?

A module is simply a `.py` file. Any Python file can be imported as a module.

<MermaidDiagram>
graph TD
  MAIN["main.py"] -- imports --> UTILS["utils.py"]
  MAIN -- imports --> MODELS["models.py"]
  UTILS -- imports --> HELPERS["helpers.py"]
  MAIN -- imports --> STD["Standard Library: os, json, math"]
  style MAIN fill:#8b5cf6,stroke:#7c3aed,color:#fff
  style STD fill:#22c55e,stroke:#16a34a,color:#fff
</MermaidDiagram>

## Import Styles

Python provides four ways to import. Each has a use case:

```python
# 1. Import entire module — access with module.function()
import math
print(math.sqrt(16))        # 4.0

# 2. Import specific items — use directly
from math import sqrt, pi
print(sqrt(16))              # 4.0
print(pi)                    # 3.14159...

# 3. Import with alias — shorter name
import datetime as dt
today = dt.date.today()

# 4. Import everything — AVOID this!
from math import *           # Pollutes your namespace
```

**Best practice:** Use option 1 or 2. Avoid `from x import *` — it makes it impossible to know where functions came from.

### Practice: Using Imports

<interactive-code>
# Standard library imports
import math
import random

# Math module
print(f"Pi: {math.pi:.4f}")
print(f"Square root of 144: {math.sqrt(144)}")
print(f"Ceiling of 4.2: {math.ceil(4.2)}")
print(f"Floor of 4.8: {math.floor(4.8)}")

# Random module
print(f"\nRandom int 1-10: {random.randint(1, 10)}")
print(f"Random choice: {random.choice(['red', 'blue', 'green'])}")

# Shuffling a list
deck = list(range(1, 11))
random.shuffle(deck)
print(f"Shuffled: {deck[:5]}...")
</interactive-code>

## Popular Standard Library Modules

Python comes with 200+ modules built in. Here are the ones you'll use most:

| Module | Purpose | Key Functions |
|--------|---------|---------------|
| `math` | Math operations | `sqrt`, `ceil`, `floor`, `pi` |
| `random` | Random numbers | `randint`, `choice`, `shuffle` |
| `datetime` | Dates and times | `date.today()`, `timedelta` |
| `json` | JSON read/write | `dumps`, `loads`, `dump`, `load` |
| `os` | Operating system | `path.exists`, `listdir`, `getcwd` |
| `sys` | System/interpreter | `argv`, `exit`, `path` |
| `collections` | Specialized containers | `Counter`, `defaultdict`, `deque` |
| `pathlib` | Modern file paths | `Path()`, `.exists()`, `.read_text()` |

## Creating Your Own Module

Any `.py` file is a module. Save functions in a file and import them:

```python
# === utils.py ===
def greet(name):
    return f"Hello, {name}!"

def add(a, b):
    return a + b

# === main.py ===
from utils import greet, add
print(greet("Alice"))
print(add(3, 5))
```

## The `if __name__ == "__main__"` Pattern

This is one of Python's most important patterns. It lets a file work both as a module AND as a standalone script:

```python
# === calculator.py ===
def add(a, b):
    return a + b

# This block runs ONLY when you execute calculator.py directly
# It does NOT run when another file imports calculator
if __name__ == "__main__":
    print("Running calculator tests...")
    print(add(2, 3))  # 5
```

### Practice: Module Pattern

<interactive-code>
# Simulating a module with functions
def celsius_to_fahrenheit(c):
    return c * 9/5 + 32

def fahrenheit_to_celsius(f):
    return (f - 32) * 5/9

# Module-level usage
temps_c = [0, 20, 37, 100]
print("Celsius → Fahrenheit:")
for temp in temps_c:
    f = celsius_to_fahrenheit(temp)
    print(f"  {temp}°C = {f:.1f}°F")

# Verify round-trip conversion
print(f"\nRound-trip: 72°F → {fahrenheit_to_celsius(72):.1f}°C → {celsius_to_fahrenheit(fahrenheit_to_celsius(72)):.1f}°F")
</interactive-code>

> **Pro Tip:** Use `from collections import Counter` for instant frequency counting: `Counter("mississippi")` → `{'s': 4, 'i': 4, 'p': 2, 'm': 1}`. It's one of the most underused standard library features.

> **Common Mistake:** Naming your file the same as a standard library module (like `random.py` or `math.py`). Python will import YOUR file instead of the standard library one, causing confusing errors.

<InlineQuiz id="quiz-import-1" question="What does 'import math' do?" options={["Downloads the math library", "Makes all math functions available as math.func()", "Copies math code into your file", "Creates a math variable"]} correct={1} explanation="import math loads the module and makes it available under the 'math' namespace. You access functions with math.sqrt(), math.pi, etc." />

<InlineQuiz id="quiz-import-2" question="What is the difference between 'import math' and 'from math import sqrt'?" options={["No difference", "The second only imports sqrt, making it available directly as sqrt()", "The first is faster", "The second imports everything"]} correct={1} explanation="'from math import sqrt' imports ONLY sqrt, and you use it directly: sqrt(4). With 'import math' you'd need math.sqrt(4)." />

<InlineQuiz id="quiz-import-3" question="Why is 'from module import *' discouraged?" options={["It is slower", "It pollutes the namespace and can cause name conflicts", "It does not work", "It only imports half the functions"]} correct={1} explanation="import * dumps all names into your namespace, making it unclear where functions come from and risking name collisions." />

<InlineQuiz id="quiz-import-4" question="What does 'import pandas as pd' do?" options={["Renames pandas permanently", "Creates an alias &apos;pd&apos; for the pandas module", "Installs pandas", "Creates a copy of pandas"]} correct={1} explanation="'as' creates an alias for the module. You can then use pd.DataFrame() instead of pandas.DataFrame(). Common aliases: np, pd, plt." />

<InlineQuiz id="quiz-import-5" question="What is __init__.py used for?" options={["Starting the program", "Marking a directory as a Python package", "Initializing variables", "Running tests"]} correct={1} explanation="__init__.py tells Python that a directory should be treated as a package. It can be empty or contain initialization code." />

<InlineQuiz id="quiz-import-6" question="What is pip?" options={["Python&apos;s built-in debugger", "Python&apos;s package installer", "A type of Python file", "A testing framework"]} correct={1} explanation="pip (Package Installer for Python) installs third-party packages from PyPI: pip install requests." />

<InlineQuiz id="quiz-import-7" question="What is a virtual environment?" options={["A cloud Python environment", "An isolated Python environment with its own packages", "A testing simulation", "A Docker container"]} correct={1} explanation="Virtual environments isolate project dependencies. Each project can have different package versions without conflicts." />

<InlineQuiz id="quiz-import-8" question="What does if __name__ == '__main__': do?" options={["Checks if the file is the main module being run directly", "Checks if the main function exists", "Checks the Python version", "Checks for imports"]} correct={0} explanation="When a file is run directly, __name__ is '__main__'. When imported, __name__ is the module name. This pattern prevents code from running on import." />

<InlineQuiz id="quiz-import-9" question="Can you import your own Python files as modules?" options={["No, only standard library", "Yes, by placing them in the same directory or package", "Only if they are .pyc files", "Only with pip install"]} correct={1} explanation="Any .py file can be imported as a module: import myfile. Python searches the current directory, PYTHONPATH, and installed packages." />

<InlineQuiz id="quiz-import-10" question="What is a circular import?" options={["Importing a module twice", "Two modules importing each other, causing an error", "Importing from a loop", "A fast import method"]} correct={1} explanation="Circular imports occur when module A imports module B and module B imports module A. This often causes ImportError. Restructure code to avoid it." />
