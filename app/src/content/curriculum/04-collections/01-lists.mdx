---
title: "Lists & Methods"
description: "Working with ordered, mutable sequences — the most versatile Python collection."
order: 1
---

# Python Lists

A list is like a numbered row of boxes — each box can hold any type of data, and you can add, remove, or rearrange boxes at any time. Lists are **ordered** (items stay in the order you put them) and **mutable** (you can change them after creation).

## Creating Lists

```python
# Empty list
empty = []

# List with items
fruits = ["apple", "banana", "cherry"]

# Mixed types (allowed, but rare in practice)
mixed = [1, "hello", True, 3.14]

# List from any iterable
chars = list("Python")   # ['P', 'y', 't', 'h', 'o', 'n']
nums = list(range(5))    # [0, 1, 2, 3, 4]
```

## Indexing: Accessing Items

Every item has a position number called an **index**. Python indexing starts at **0**, not 1.

<MermaidDiagram>
graph LR
  I0["Index 0"] --> A["apple"]
  I1["Index 1"] --> B["banana"]
  I2["Index 2"] --> C["cherry"]
  IN1["Index -1"] --> C
  IN2["Index -2"] --> B
  IN3["Index -3"] --> A
  style I0 fill:#3b82f6,stroke:#2563eb,color:#fff
  style IN1 fill:#f59e0b,stroke:#d97706,color:#000
</MermaidDiagram>

```python
fruits = ["apple", "banana", "cherry"]
fruits[0]    # "apple"  — first item
fruits[-1]   # "cherry" — last item (negative = count from end)
fruits[1:3]  # ["banana", "cherry"] — slice from index 1 to 2
```

## Slicing: Getting Subsets

Slicing uses the syntax `list[start:stop:step]`. The `stop` index is **excluded**.

```python
nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
nums[2:5]     # [2, 3, 4]      — from index 2 to 4
nums[:3]      # [0, 1, 2]      — from start to index 2
nums[7:]      # [7, 8, 9]      — from index 7 to end
nums[::2]     # [0, 2, 4, 6, 8] — every 2nd item
nums[::-1]    # [9, 8, 7,..., 0] — reversed!
```

<MethodUnit category="list-methods" />

## Essential List Methods

| Method | What it does | Example |
|--------|-------------|---------|
| `.append(x)` | Add to end | `nums.append(4)` |
| `.insert(i, x)` | Add at position | `nums.insert(0, "first")` |
| `.remove(x)` | Remove first occurrence | `nums.remove(3)` |
| `.pop(i)` | Remove and return item at index | `nums.pop(-1)` |
| `.sort()` | Sort in place | `nums.sort()` |
| `.reverse()` | Reverse in place | `nums.reverse()` |
| `.index(x)` | Find position of value | `nums.index(3)` |
| `.count(x)` | Count occurrences | `nums.count(3)` |

### Practice: List Operations

<interactive-code>
# Build a shopping list
cart = []
cart.append("milk")
cart.append("eggs")
cart.append("bread")
cart.insert(0, "butter")   # Add at the beginning
print("Cart:", cart)

# Remove an item
cart.remove("eggs")
print("After removing eggs:", cart)

# Pop the last item
last = cart.pop()
print(f"Checked out: {last}")
print("Remaining:", cart)

# Sorting
scores = [88, 45, 92, 67, 100, 73]
scores.sort(reverse=True)
print(f"\nTop scores: {scores}")

# Searching
print(f"Position of 92: index {scores.index(92)}")
print(f"How many 88s: {scores.count(88)}")
</interactive-code>

## List Comprehensions: The Pythonic Way

List comprehensions let you create new lists from existing ones in a single, readable line:

```python
# Without comprehension
squares = []
for x in range(10):
    squares.append(x ** 2)

# With comprehension — same result, one line
squares = [x ** 2 for x in range(10)]
```

You can add conditions too:

```python
# Only even squares
even_squares = [x ** 2 for x in range(10) if x % 2 == 0]
# [0, 4, 16, 36, 64]
```

### Practice: Comprehensions

<interactive-code>
# Basic comprehension
doubles = [n * 2 for n in range(1, 6)]
print(f"Doubles: {doubles}")

# With filter
names = ["Alice", "Bob", "Charlie", "Dave", "Eve"]
long_names = [name for name in names if len(name) > 3]
print(f"Long names: {long_names}")

# Transform + filter
words = ["Hello", "WORLD", "python", "CODE"]
lower_short = [w.lower() for w in words if len(w) <= 5]
print(f"Short lowercase: {lower_short}")
</interactive-code>

> **Pro Tip:** `append()` is O(1) — instant. `insert(0, x)` is O(n) — slow for large lists because every item shifts. If you need fast left-side insertion, use `collections.deque`.

> **Common Mistake:** `sorted(my_list)` returns a NEW list. `my_list.sort()` modifies the original and returns `None`. Don't write `x = my_list.sort()` — `x` will be `None`.

<InlineQuiz
  id="quiz-lists-1"
  question="What does [1, 2, 3].append(4) return?"
  options={["[1, 2, 3, 4]", "4", "None", "[4, 1, 2, 3]"]}
  correct={2}
  explanation="append() modifies the list IN PLACE and returns None. The list itself changes to [1, 2, 3, 4], but the return value is None. This is a common gotcha!"
/>

<InlineQuiz id="quiz-lists-2" question="What is the difference between a list and a tuple?" options={["No difference", "Lists are mutable, tuples are immutable", "Tuples are faster, lists are safer", "Lists use [], tuples use () but both are mutable"]} correct={1} explanation="Lists are mutable (can be changed after creation), tuples are immutable (cannot be changed). Lists use [], tuples use ()." />

<InlineQuiz id="quiz-lists-3" question="What does list slicing [1:4] return?" options={["Elements at index 1 to 4 inclusive", "Elements at index 1 to 3 inclusive", "Elements at index 0 to 4", "The first 4 elements"]} correct={1} explanation="Slicing [start:stop] includes the start index but EXCLUDES the stop index. [1:4] returns elements at indices 1, 2, and 3." />

<InlineQuiz id="quiz-lists-4" question="How do you add an item to the end of a list?" options={["list.add(item)", "list.append(item)", "list.insert(item)", "list.push(item)"]} correct={1} explanation="append() adds a single item to the end. insert(index, item) adds at a specific position. Python lists don't have add() or push()." />

<InlineQuiz id="quiz-lists-5" question="What does list.pop() do?" options={["Removes the first element", "Removes and returns the last element", "Returns the last element without removing", "Clears the entire list"]} correct={1} explanation="pop() removes and returns the last element. You can also pop(index) to remove at a specific position." />

<InlineQuiz id="quiz-lists-6" question="What is the output of: [1, 2, 3] + [4, 5]?" options={["[1, 2, 3, 4, 5]", "[5, 7, 3]", "Error", "[[1,2,3],[4,5]]"]} correct={0} explanation="The + operator concatenates lists, creating a new list with all elements: [1, 2, 3, 4, 5]." />

<InlineQuiz id="quiz-lists-7" question="What does list[::-1] do?" options={["Returns the first element", "Returns the last element", "Reverses the list", "Removes all elements"]} correct={2} explanation="[::-1] is a slice with step -1, which reverses the list. It creates a new reversed copy without modifying the original." />

<InlineQuiz id="quiz-lists-8" question="How do you check if an item is in a list?" options={["list.contains(item)", "list.has(item)", "item in list", "list.find(item)"]} correct={2} explanation="The 'in' operator checks membership: 'if item in list:'. It returns True if the item exists in the list." />

<InlineQuiz id="quiz-lists-9" question="What is a nested list?" options={["A list with no elements", "A list that contains other lists", "A list sorted alphabetically", "A list with unique elements only"]} correct={1} explanation="A nested list is a list containing other lists: [[1,2], [3,4]]. It can represent grids, matrices, or hierarchical data." />

<InlineQuiz id="quiz-lists-10" question="What does list.extend([4, 5]) do?" options={["Adds [4,5] as a single element", "Adds 4 and 5 as separate elements", "Returns a new extended list", "Raises an error"]} correct={1} explanation="extend() adds each element individually. append([4,5]) would add the list as a single element, but extend() unpacks it." />
