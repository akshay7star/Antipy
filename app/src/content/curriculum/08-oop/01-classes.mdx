---
title: "Classes & Objects"
description: "The building blocks of Object-Oriented Programming — bundling data with behavior."
order: 1
---

# Object-Oriented Programming (OOP)

Everything in Python is an object — strings, lists, dictionaries, even functions. OOP is a way to create your OWN objects by defining **classes**. A class is like a blueprint, and objects are instances built from that blueprint.

## The Real-World Analogy

Think of a class as a **cookie cutter** and objects as the **cookies**. The cookie cutter defines the shape (what properties and methods every cookie has), but each cookie can have different decorations (different property values).

<MermaidDiagram>
graph TD
  CLASS["Class: Dog blueprint"] --> OBJ1["Object: Buddy, age 3"]
  CLASS --> OBJ2["Object: Max, age 5"]
  CLASS --> OBJ3["Object: Bella, age 1"]
  style CLASS fill:#8b5cf6,stroke:#7c3aed,color:#fff
  style OBJ1 fill:#3b82f6,stroke:#2563eb,color:#fff
  style OBJ2 fill:#3b82f6,stroke:#2563eb,color:#fff
  style OBJ3 fill:#3b82f6,stroke:#2563eb,color:#fff
</MermaidDiagram>

## Your First Class

```python
class Dog:
    def __init__(self, name, breed, age):    # Constructor — runs when creating a new Dog
        self.name = name                      # Instance attribute
        self.breed = breed
        self.age = age
    
    def bark(self):                           # Method — a function belonging to the class
        return f"{self.name} says Woof!"
    
    def birthday(self):
        self.age += 1
        return f"{self.name} is now {self.age}!"
```

**Key concepts:**
- **`__init__`** — the constructor, runs automatically when you create an object
- **`self`** — refers to the current object instance (like "this" in Java/JS)
- **Attributes** — data stored on the object (`self.name`, `self.age`)
- **Methods** — functions that belong to the object (`bark()`, `birthday()`)

### Practice: Create a Class

<interactive-code>
class Dog:
    def __init__(self, name, breed, age):
        self.name = name
        self.breed = breed
        self.age = age
    
    def bark(self):
        return f"{self.name} says Woof!"
    
    def describe(self):
        return f"{self.name} is a {self.age}-year-old {self.breed}"

# Create objects (instances)
buddy = Dog("Buddy", "Golden Retriever", 3)
max_dog = Dog("Max", "German Shepherd", 5)

print(buddy.describe())
print(max_dog.describe())
print(buddy.bark())

# Each object has its own data
print(f"\n{buddy.name}'s age: {buddy.age}")
print(f"{max_dog.name}'s age: {max_dog.age}")
</interactive-code>

<MethodUnit category="oop" />

## Inheritance: Building on Existing Classes

Inheritance lets you create a new class based on an existing one. The new class (child) inherits all methods and attributes from the parent, and can add or override them.

<MermaidDiagram>
graph TD
  ANIMAL["Animal: name, speak"] --> DOG["Dog: breed, fetch"]
  ANIMAL --> CAT["Cat: indoor, purr"]
  DOG --> PUPPY["Puppy: tricks"]
  style ANIMAL fill:#8b5cf6,stroke:#7c3aed,color:#fff
  style DOG fill:#3b82f6,stroke:#2563eb,color:#fff
  style CAT fill:#22c55e,stroke:#16a34a,color:#fff
</MermaidDiagram>

```python
class Animal:                           # Parent class
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        return f"{self.name} makes a sound"

class Dog(Animal):                      # Child class — inherits from Animal
    def speak(self):                    # Override parent method
        return f"{self.name} barks!"

class Cat(Animal):
    def speak(self):
        return f"{self.name} meows!"
```

### Practice: Inheritance

<interactive-code>
class Vehicle:
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
        self.speed = 0
    
    def accelerate(self, amount):
        self.speed += amount
        return f"{self.make} {self.model} going {self.speed} mph"
    
    def brake(self):
        self.speed = max(0, self.speed - 10)
        return f"Slowing to {self.speed} mph"

class ElectricCar(Vehicle):
    def __init__(self, make, model, year, battery_kwh):
        super().__init__(make, model, year)  # Call parent constructor
        self.battery = battery_kwh
        self.charge = 100  # percent
    
    def status(self):
        return f"{self.make} {self.model}: {self.speed}mph, {self.charge}% charge"

# Create a Tesla
tesla = ElectricCar("Tesla", "Model 3", 2024, 75)
print(tesla.accelerate(30))   # Inherited method
print(tesla.accelerate(25))
print(tesla.status())          # ElectricCar's own method
print(tesla.brake())           # Inherited method
</interactive-code>

## Dunder Methods (Magic Methods)

Methods with double underscores (`__method__`) give your objects special powers — making them printable, comparable, iterable, and more.

| Method | Purpose | Triggered By |
|--------|---------|-------------|
| `__init__` | Constructor | `MyClass()` |
| `__str__` | String representation | `print(obj)`, `str(obj)` |
| `__repr__` | Developer representation | REPL, debugging |
| `__len__` | Length | `len(obj)` |
| `__eq__` | Equality | `obj1 == obj2` |
| `__lt__` | Less than | `obj1 < obj2`, `sorted()` |
| `__add__` | Addition | `obj1 + obj2` |

### Practice: Magic Methods

<interactive-code>
class Money:
    def __init__(self, amount, currency="USD"):
        self.amount = amount
        self.currency = currency
    
    def __str__(self):
        return f"${self.amount:.2f} {self.currency}"
    
    def __repr__(self):
        return f"Money({self.amount}, '{self.currency}')"
    
    def __add__(self, other):
        if self.currency != other.currency:
            raise ValueError("Cannot add different currencies!")
        return Money(self.amount + other.amount, self.currency)
    
    def __eq__(self, other):
        return self.amount == other.amount and self.currency == other.currency
    
    def __lt__(self, other):
        return self.amount < other.amount

# Test it out
price = Money(29.99)
tax = Money(2.40)
total = price + tax

print(f"Price: {price}")
print(f"Tax:   {tax}")
print(f"Total: {total}")
print(f"Equal? {price == Money(29.99)}")

# Sorting works because we defined __lt__
prices = [Money(50), Money(10), Money(30)]
for p in sorted(prices):
    print(f"  {p}")
</interactive-code>

> **Pro Tip:** Always define `__str__` on your classes. Without it, `print(obj)` shows unhelpful output like `<__main__.Dog object at 0x...>`. With `__str__`, you get human-readable output.

> **Common Mistake:** Forgetting `self` as the first parameter in methods. `def bark():` will crash when called. It must be `def bark(self):`.

<InlineQuiz
  id="quiz-oop-1"
  question="What does the 'self' parameter refer to in a Python class method?"
  options={["The class itself", "The current instance of the class", "The parent class", "It has no meaning, it is just a convention"]}
  correct={1}
  explanation="'self' refers to the current instance of the class. When you call obj.method(), Python automatically passes 'obj' as the 'self' parameter. It lets each instance access its own attributes."
/>

<InlineQuiz id="quiz-oop-2" question="What is the __init__ method?" options={["A destructor", "The constructor � called when creating a new instance", "A class method", "A static method"]} correct={1} explanation="__init__ is the constructor method. It's automatically called when you create a new instance: obj = MyClass(). Use it to set initial attributes." />

<InlineQuiz id="quiz-oop-3" question="What is inheritance?" options={["Copying a class", "A child class acquiring methods and attributes from a parent class", "Deleting a class", "Renaming a class"]} correct={1} explanation="Inheritance lets a child class inherit methods and attributes from a parent: class Dog(Animal):. The child can also override or extend parent behavior." />

<InlineQuiz id="quiz-oop-4" question="What is encapsulation?" options={["Making all attributes public", "Bundling data and methods together, controlling access", "Running code in parallel", "Converting to JSON"]} correct={1} explanation="Encapsulation bundles data and methods while controlling access. Python uses _ prefix for protected and __ for name-mangled (private) attributes." />

<InlineQuiz id="quiz-oop-5" question="What does super() do?" options={["Creates a superclass", "Calls a method from the parent class", "Makes a method faster", "Deletes the parent class"]} correct={1} explanation="super() returns a proxy to the parent class, allowing you to call parent methods: super().__init__(). Essential in inheritance." />

<InlineQuiz id="quiz-oop-6" question="What is polymorphism?" options={["Having multiple constructors", "Different classes responding to the same method differently", "Using only one class", "A type of error"]} correct={1} explanation="Polymorphism means the same method name can behave differently depending on the object. Dog.speak() -> 'Woof', Cat.speak() -> 'Meow'." />

<InlineQuiz id="quiz-oop-7" question="What is a class attribute vs an instance attribute?" options={["Same thing", "Class attributes are shared by all instances, instance attributes are unique to each", "Instance attributes are shared, class attributes are unique", "Class attributes cannot be changed"]} correct={1} explanation="Class attributes are shared across ALL instances. Instance attributes (set via self.x) are unique to each object." />

<InlineQuiz id="quiz-oop-8" question="What is the @property decorator used for?" options={["Making a method behave like an attribute", "Protecting a variable", "Defining class methods", "Logging method calls"]} correct={0} explanation="@property lets you access a method as if it were an attribute: obj.name instead of obj.name(). Useful for computed values with getter/setter logic." />

<InlineQuiz id="quiz-oop-9" question="What is a @classmethod?" options={["A regular method", "A method that receives the class (cls) instead of the instance (self)", "A private method", "A static method"]} correct={1} explanation="@classmethod receives the class itself as the first argument (cls), not an instance. Often used as alternative constructors." />

<InlineQuiz id="quiz-oop-10" question="What are dunder (magic) methods?" options={["Methods that are slow", "Methods with double underscores like __str__, __len__", "Methods defined in C", "Deprecated methods"]} correct={1} explanation="Dunder methods (double underscore) like __str__, __repr__, __len__, __eq__ customize how objects behave with operators and built-in functions." />
