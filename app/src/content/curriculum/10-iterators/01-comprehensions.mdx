---
title: "Comprehensions"
description: "Building collections in one line — Python's most elegant syntax."
order: 1
---

# Comprehensions: The Pythonic Way

Comprehensions are one-line expressions that create new collections from existing ones. They replace multi-line loops with a compact, readable syntax that experienced developers consider the hallmark of "Pythonic" code.

## List Comprehensions

The most common type. The pattern is: `[expression for item in iterable if condition]`

```python
# Traditional loop
squares = []
for x in range(10):
    squares.append(x ** 2)

# List comprehension — same result, one line
squares = [x ** 2 for x in range(10)]
```

<MermaidDiagram>
graph LR
  INPUT["Iterable: range(10)"] --> FILTER{"Filter: if condition"}
  FILTER --> TRANSFORM["Transform: expression"]
  TRANSFORM --> OUTPUT["New List"]
  style INPUT fill:#3b82f6,stroke:#2563eb,color:#fff
  style OUTPUT fill:#22c55e,stroke:#16a34a,color:#fff
</MermaidDiagram>

### With Filtering

```python
# Only even squares
even_squares = [x ** 2 for x in range(10) if x % 2 == 0]
# [0, 4, 16, 36, 64]
```

### Practice: List Comprehensions

<interactive-code>
# Basic transformation
names = ["alice", "bob", "charlie", "diana"]
capitalized = [name.title() for name in names]
print(f"Capitalized: {capitalized}")

# Filter + transform
scores = [45, 92, 78, 31, 88, 67, 95, 55]
passing = [s for s in scores if s >= 70]
print(f"Passing scores: {passing}")

# Nested comprehension — flatten a 2D list
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = [num for row in matrix for num in row]
print(f"Flattened: {flat}")

# With conditional expression (ternary)
labels = ["PASS" if s >= 70 else "FAIL" for s in scores]
print(f"Labels: {labels}")
</interactive-code>

## Dict Comprehensions

Same concept, but creates dictionaries:

```python
names = ["Alice", "Bob", "Charlie"]
name_lengths = {name: len(name) for name in names}
# {'Alice': 5, 'Bob': 3, 'Charlie': 7}
```

## Set Comprehensions

Creates sets (unique values only):

```python
words = ["hello", "HELLO", "Hello", "world"]
unique_lower = {w.lower() for w in words}
# {'hello', 'world'}
```

### Practice: All Comprehension Types

<interactive-code>
# Dict comprehension — word frequency
sentence = "the cat sat on the mat the cat"
words = sentence.split()
freq = {word: words.count(word) for word in set(words)}
print(f"Frequency: {freq}")

# Set comprehension — unique first letters
names = ["Alice", "Amanda", "Bob", "Brian", "Charlie"]
initials = {name[0] for name in names}
print(f"Initials: {sorted(initials)}")

# Inverting a dictionary
original = {"a": 1, "b": 2, "c": 3}
inverted = {v: k for k, v in original.items()}
print(f"Inverted: {inverted}")
</interactive-code>

> **Pro Tip:** If your comprehension is hard to read, write the loop instead. Readability beats cleverness. A good rule: if the comprehension doesn't fit on one line, use a regular loop.

> **Common Mistake:** Nesting too many levels. `[x for row in matrix for x in row if x > 3]` is fine. Adding a third level makes it unreadable — use loops instead.

<InlineQuiz
  id="quiz-comprehensions-1"
  question="What does [x**2 for x in range(5)] produce?"
  options={["[1, 4, 9, 16, 25]", "[0, 1, 4, 9, 16]", "[0, 2, 4, 6, 8]", "[1, 2, 3, 4, 5]"]}
  correct={1}
  explanation="range(5) gives [0, 1, 2, 3, 4]. Squaring each: 0**2=0, 1**2=1, 2**2=4, 3**2=9, 4**2=16. Result: [0, 1, 4, 9, 16]."
/>

<InlineQuiz id="quiz-comp-2" question="What is the syntax for a list comprehension with a condition?" options={["[x for x in list if x > 0]", "[if x > 0: x for x in list]", "[x if x > 0 for x in list]", "[for x in list if x > 0: x]"]} correct={0} explanation="The filter goes at the END: [expression for item in iterable if condition]. The 'if' filters which items are included." />

<InlineQuiz id="quiz-comp-3" question="What is a dictionary comprehension?" options={["A way to read dictionaries", "{key: value for item in iterable}", "dict(list)", "A sorting algorithm"]} correct={1} explanation="Dict comprehensions create dicts: {x: x**2 for x in range(5)} creates {0:0, 1:1, 2:4, 3:9, 4:16}." />

<InlineQuiz id="quiz-comp-4" question="What is a generator expression?" options={["[x for x in range(10)]", "(x for x in range(10))", "{x for x in range(10)}", "x for x in range(10)"]} correct={1} explanation="Generator expressions use () instead of []. They produce values lazily (one at a time) instead of creating a full list in memory." />

<InlineQuiz id="quiz-comp-5" question="Why are generator expressions more memory-efficient?" options={["They use less CPU", "They produce values one at a time instead of all at once", "They compress data", "They are not more efficient"]} correct={1} explanation="Generators yield values on demand (lazy evaluation). A list comprehension creates the entire list in memory; a generator only holds one value at a time." />

<InlineQuiz id="quiz-comp-6" question="Can you nest comprehensions?" options={["No", "Yes: [x for sublist in matrix for x in sublist]", "Only with explicit loops", "Only for lists"]} correct={1} explanation="Nested comprehensions flatten nested structures: [x for row in matrix for x in row] takes a 2D list and flattens it to 1D." />

<InlineQuiz id="quiz-comp-7" question="What does {x for x in [1, 2, 2, 3, 3]} produce?" options={["[1, 2, 2, 3, 3]", "{1, 2, 3}", "{1, 2, 2, 3, 3}", "Error"]} correct={1} explanation="Using {} with a comprehension (no key:value) creates a SET comprehension. Sets remove duplicates, so you get {1, 2, 3}." />

<InlineQuiz id="quiz-comp-8" question="When should you use a regular loop instead of a comprehension?" options={["Always", "When the logic is complex or has side effects", "Never, comprehensions are always better", "Only for small data"]} correct={1} explanation="Use regular loops for complex logic, multiple statements, side effects, or when readability suffers. Comprehensions are for simple transformations." />

<InlineQuiz id="quiz-comp-9" question="What does [x.upper() for x in ['a', 'b', 'c']] produce?" options={["[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]", "[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]", "ABC", "Error"]} correct={0} explanation="The comprehension applies .upper() to each element, producing ['A', 'B', 'C']. You can call any method or function in the expression." />

<InlineQuiz id="quiz-comp-10" question="What is the ternary expression in a comprehension?" options={["The for clause", "value_if_true if condition else value_if_false", "The if filter at the end", "A three-element list"]} correct={1} explanation="You can use ternary expressions in the expression part: [x if x > 0 else 0 for x in nums]. Note this is DIFFERENT from the filter at the end." />
