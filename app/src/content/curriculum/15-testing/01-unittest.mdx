---
title: "Unit Testing"
description: "Writing tests that catch bugs before users do."
order: 1
---

# Testing: Your Safety Net

<FunctionsVisualizer />

Testing is the difference between "it works on my machine" and "it works everywhere." Tests are automated scripts that verify your code behaves correctly. Every professional codebase has them, and writing them is a core developer skill.

## Why Test?

<MermaidDiagram>
graph LR
  CODE["Write Code"] --> TEST["Run Tests"]
  TEST -- Pass --> SHIP["Ship with confidence"]
  TEST -- Fail --> FIX["Fix the bug"]
  FIX --> TEST
  style SHIP fill:#22c55e,stroke:#16a34a,color:#fff
  style FIX fill:#ef4444,stroke:#dc2626,color:#fff
</MermaidDiagram>

- **Catch bugs early** — before users find them
- **Refactor safely** — change code knowing tests will catch regressions
- **Document behavior** — tests show how your code is supposed to work
- **Save time** — manual testing doesn't scale

## Python's unittest Module

```python
import unittest

class TestCalculator(unittest.TestCase):
    def test_add(self):
        self.assertEqual(2 + 2, 4)
    
    def test_divide(self):
        self.assertAlmostEqual(10 / 3, 3.333, places=2)
    
    def test_divide_by_zero(self):
        with self.assertRaises(ZeroDivisionError):
            1 / 0
```

## Key Assertions

| Assertion | Checks |
|-----------|--------|
| `assertEqual(a, b)` | `a == b` |
| `assertNotEqual(a, b)` | `a != b` |
| `assertTrue(x)` | `x is True` |
| `assertFalse(x)` | `x is False` |
| `assertIn(a, b)` | `a in b` |
| `assertRaises(Error)` | Exception is raised |
| `assertAlmostEqual(a, b)` | Floats are close |
| `assertIsNone(x)` | `x is None` |

### Practice: Writing Tests

<interactive-code>
# The code to test
def calculate_grade(score):
    if not isinstance(score, (int, float)):
        raise TypeError("Score must be a number")
    if score < 0 or score > 100:
        raise ValueError("Score must be 0-100")
    if score >= 90: return "A"
    if score >= 80: return "B"
    if score >= 70: return "C"
    if score >= 60: return "D"
    return "F"

# Tests
def run_tests():
    # Test normal cases
    assert calculate_grade(95) == "A", "95 should be A"
    assert calculate_grade(85) == "B", "85 should be B"
    assert calculate_grade(75) == "C", "75 should be C"
    assert calculate_grade(65) == "D", "65 should be D"
    assert calculate_grade(50) == "F", "50 should be F"
    
    # Test edge cases
    assert calculate_grade(90) == "A", "90 boundary"
    assert calculate_grade(0) == "F", "0 should be F"
    assert calculate_grade(100) == "A", "100 should be A"
    
    # Test error cases
    try:
        calculate_grade(-1)
        assert False, "Should have raised ValueError"
    except ValueError:
        pass
    
    try:
        calculate_grade("ninety")
        assert False, "Should have raised TypeError"
    except TypeError:
        pass
    
    print("All 10 tests passed!")

run_tests()
</interactive-code>

## Test Structure: Arrange, Act, Assert

Every test follows the **AAA** pattern:

```python
def test_user_creation(self):
    # Arrange — set up the test data
    name = "Alice"
    age = 30
    
    # Act — run the code being tested
    user = create_user(name, age)
    
    # Assert — verify the result
    self.assertEqual(user.name, "Alice")
    self.assertEqual(user.age, 30)
```

> **Pro Tip:** Test edge cases: empty inputs, zero, negative numbers, very large values, `None`, and boundary values. Bugs hide at the edges.

> **Common Mistake:** Only testing the "happy path." If your function handles errors, test that the errors are raised correctly too.

<InlineQuiz id="quiz-test-1" question="Why is testing important?" options={["It makes code run faster", "It catches bugs early and ensures code works as expected", "It is only for large projects", "It replaces documentation"]} correct={1} explanation="Testing catches bugs before they reach production, validates behavior, and gives confidence when refactoring code." />

<InlineQuiz id="quiz-test-2" question="What is a unit test?" options={["A test of the entire application", "A test of a single function or method in isolation", "A performance test", "A user interface test"]} correct={1} explanation="Unit tests test individual functions or methods in isolation. They should be fast, independent, and test one thing." />

<InlineQuiz id="quiz-test-3" question="What does assertEqual(a, b) check?" options={["a is b", "a == b", "a > b", "a != b"]} correct={1} explanation="assertEqual checks that two values are equal: self.assertEqual(add(2, 3), 5) passes if add(2, 3) returns 5." />

<InlineQuiz id="quiz-test-4" question="What does assertTrue(x) check?" options={["x is True exactly", "bool(x) is True (truthy)", "x == 1", "x exists"]} correct={1} explanation="assertTrue checks that the expression is truthy (evaluates to True in boolean context). assertFalse checks for falsy." />

<InlineQuiz id="quiz-test-5" question="What is assertRaises used for?" options={["Raising an error", "Checking that a specific exception is raised", "Testing error messages", "Catching all errors"]} correct={1} explanation="assertRaises checks that code raises an expected exception: with self.assertRaises(ValueError): int('abc')." />

<InlineQuiz id="quiz-test-6" question="What is the AAA pattern in testing?" options={["Ask, Answer, Assert", "Arrange, Act, Assert", "Assign, Apply, Analyze", "Always Assert Accurately"]} correct={1} explanation="Arrange (setup), Act (execute the code), Assert (verify the result). This pattern makes tests clear and organized." />

<InlineQuiz id="quiz-test-7" question="How do you run unittest tests?" options={["python test.py", "python -m unittest test_module", "run tests", "test()"]} correct={1} explanation="python -m unittest discovers and runs tests. You can also use python -m unittest discover for automatic test discovery." />

<InlineQuiz id="quiz-test-8" question="What is setUp() used for?" options={["Setting up the database", "Running code before EACH test method", "Starting the test runner", "Installing dependencies"]} correct={1} explanation="setUp() runs before each test method, preparing common test data or objects. tearDown() runs after each test for cleanup." />

<InlineQuiz id="quiz-test-9" question="What is test coverage?" options={["The number of tests", "The percentage of code that is executed by tests", "The test execution time", "The number of assertions"]} correct={1} explanation="Test coverage measures what percentage of your code is actually run during testing. 100% coverage doesn't mean bug-free, but low coverage means untested code." />

<InlineQuiz id="quiz-test-10" question="What is mocking in testing?" options={["Making fun of code", "Replacing real objects with fake ones for isolated testing", "Testing mock-ups", "Creating test data"]} correct={1} explanation="Mocking replaces real dependencies (APIs, databases) with controlled fakes. unittest.mock provides Mock and patch for this." />
