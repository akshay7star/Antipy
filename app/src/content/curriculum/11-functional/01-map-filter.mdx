---
title: "Map, Filter & Reduce"
description: "Functional programming tools for transforming and filtering data."
order: 1
---

# Functional Tools: Transform Data without Loops

Python supports **functional programming** — a style where you transform data by passing functions to other functions. The three core functional tools are `map()`, `filter()`, and `reduce()`. They replace common loop patterns with cleaner, more declarative code.

## map() — Transform Every Item

`map()` applies a function to every item in an iterable and returns the results:

<MermaidDiagram>
graph LR
  IN["[1, 2, 3, 4]"] --> MAP["map: x * 2"]
  MAP --> OUT["[2, 4, 6, 8]"]
  style IN fill:#3b82f6,stroke:#2563eb,color:#fff
  style OUT fill:#22c55e,stroke:#16a34a,color:#fff
</MermaidDiagram>

```python
nums = [1, 2, 3, 4]
doubled = list(map(lambda x: x * 2, nums))
# [2, 4, 6, 8]
```

## filter() — Keep Only Matching Items

`filter()` keeps items where the function returns `True`:

```python
nums = [1, 2, 3, 4, 5, 6, 7, 8]
evens = list(filter(lambda x: x % 2 == 0, nums))
# [2, 4, 6, 8]
```

## reduce() — Combine All Items into One Value

`reduce()` processes items left-to-right, accumulating a single result:

```python
from functools import reduce

nums = [1, 2, 3, 4]
total = reduce(lambda acc, x: acc + x, nums)
# ((1+2)+3)+4 = 10
```

<MethodUnit category="built-in-functions" />

### Practice: Functional Transformations

<interactive-code>
from functools import reduce

# map — convert temperatures
celsius = [0, 20, 37, 100]
fahrenheit = list(map(lambda c: c * 9/5 + 32, celsius))
print(f"Celsius: {celsius}")
print(f"Fahrenheit: {fahrenheit}")

# filter — find passing students
students = [
    {"name": "Alice", "score": 92},
    {"name": "Bob", "score": 55},
    {"name": "Charlie", "score": 78},
    {"name": "Diana", "score": 45},
]
passed = list(filter(lambda s: s["score"] >= 70, students))
print(f"\nPassing: {[s['name'] for s in passed]}")

# reduce — find the product of all numbers
nums = [2, 3, 4, 5]
product = reduce(lambda a, b: a * b, nums)
print(f"\nProduct of {nums} = {product}")

# Combining all three — pipeline
data = [1, -2, 3, -4, 5, -6, 7, -8, 9, -10]
result = reduce(
    lambda a, b: a + b,
    map(lambda x: x ** 2,
        filter(lambda x: x > 0, data))
)
print(f"\nSum of squares of positives: {result}")
</interactive-code>

## Comprehensions vs Functional

Modern Python often prefers **comprehensions** over `map`/`filter` because they're more readable:

```python
# Functional style
result = list(map(lambda x: x**2, filter(lambda x: x > 0, nums)))

# Comprehension style — usually clearer
result = [x**2 for x in nums if x > 0]
```

> **Pro Tip:** Use `map`/`filter` when you already have a named function to apply: `list(map(str, numbers))` is cleaner than `[str(n) for n in numbers]`.

> **Common Mistake:** Forgetting that `map()` and `filter()` return iterators in Python 3, not lists. Wrap with `list()` if you need to use the result multiple times.

<InlineQuiz id="quiz-mapf-1" question="What does map(func, iterable) do?" options={["Filters elements", "Applies func to each element and returns an iterator", "Sorts the iterable", "Counts elements"]} correct={1} explanation="map() applies a function to every element in the iterable: map(str.upper, ['a','b']) produces an iterator of ['A','B']." />

<InlineQuiz id="quiz-mapf-2" question="What does filter(func, iterable) do?" options={["Transforms each element", "Keeps only elements where func returns True", "Removes duplicates", "Sorts the iterable"]} correct={1} explanation="filter() keeps elements that pass the test: filter(lambda x: x > 0, [-1, 2, -3, 4]) keeps [2, 4]." />

<InlineQuiz id="quiz-mapf-3" question="Do map() and filter() return lists?" options={["Yes, always", "No, they return iterators (lazy)", "Only in Python 2", "Only map returns a list"]} correct={1} explanation="In Python 3, map() and filter() return lazy iterators. Wrap with list() to get a list: list(map(func, data))." />

<InlineQuiz id="quiz-mapf-4" question="What does reduce(func, iterable) do?" options={["Filters elements", "Combines elements into a single value", "Maps a function", "Removes duplicates"]} correct={1} explanation="reduce() from functools applies a function cumulatively: reduce(lambda a, b: a+b, [1,2,3,4]) computes ((1+2)+3)+4 = 10." />

<InlineQuiz id="quiz-mapf-5" question="Which is more Pythonic: map(func, list) or a list comprehension?" options={["map() is always better", "List comprehensions are generally preferred in Python", "They are identical", "Neither, use a for loop"]} correct={1} explanation="List comprehensions are considered more Pythonic and readable: [func(x) for x in list] vs list(map(func, list))." />

<InlineQuiz id="quiz-mapf-6" question="What does any() do?" options={["Returns True if ALL elements are truthy", "Returns True if ANY element is truthy", "Returns the first truthy element", "Counts truthy elements"]} correct={1} explanation="any() returns True if at least one element is truthy. any([False, False, True]) -> True. Useful with generator expressions." />

<InlineQuiz id="quiz-mapf-7" question="What does all() do?" options={["Returns True if ANY element is truthy", "Returns True if ALL elements are truthy", "Returns all elements", "Removes falsy elements"]} correct={1} explanation="all() returns True only if every element is truthy. all([True, True, False]) -> False. all([]) -> True (vacuously true)." />

<InlineQuiz id="quiz-mapf-8" question="What is a higher-order function?" options={["A function with many parameters", "A function that takes or returns other functions", "A recursive function", "A class method"]} correct={1} explanation="Higher-order functions accept functions as arguments or return functions. map(), filter(), sorted(key=func) are all higher-order functions." />

<InlineQuiz id="quiz-mapf-9" question="What does sorted(data, key=len) do?" options={["Sorts by value", "Sorts by the length of each element", "Sorts in reverse", "Filters by length"]} correct={1} explanation="The key parameter specifies a function to extract a comparison key. key=len sorts elements by their length." />

<InlineQuiz id="quiz-mapf-10" question="Can you chain map and filter?" options={["No", "Yes: map(func, filter(pred, data))", "Only with reduce", "Only in functional languages"]} correct={1} explanation="You can chain them: map(str.upper, filter(lambda s: len(s) > 3, words)) � first filter, then transform. Or use comprehensions." />
